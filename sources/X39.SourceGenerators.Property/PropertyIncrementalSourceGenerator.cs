using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace X39.SourceGenerators.Property;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class PropertyIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string RangeAttribute     = "System.ComponentModel.DataAnnotations.RangeAttribute";
    private const string MaxLengthAttribute = "System.ComponentModel.DataAnnotations.MaxLengthAttribute";

    private const string AttributeSourceCode =
        """
        // <auto-generated/>
        #nullable enable
        using System;
        using System.Runtime.CompilerServices;

        namespace X39.SourceGenerators.Property
        {
            /// <summary>
            /// Makes the field or class, annotated with the 'NotifyPropertyChanged' attribute, create
            /// properties which raise the PropertyChanged event when changed.
            /// For a decorated class, all fields will be considered for property generation and the
            /// PropertyChanged event will be implemented too.
            /// </summary>
            /// <remarks>
            /// The name of the property generated will be the Capitalized name of the field, minus any leading underscores.
            /// If the field is annotated with the 'PropertyName' attribute,
            /// the name of the property will be the value of the 'PropertyName' attribute.
            /// </remarks>
            /// <param name="generateEvent">
            ///     If true, the PropertyChanged event will be generated (as in: Added to the generated class).
            ///     If false, the PropertyChanged event will not be generated and must be supplied by the user.
            /// </param>
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            [CompilerGenerated]
            public class NotifyPropertyChangedAttribute(bool generateEvent = true) : Attribute {}
            
            /// <summary>
            /// Makes the field or class, annotated with the 'NotifyPropertyChanging' attribute, create
            /// properties which raise the PropertyChanging event when changed.
            /// For a decorated class, all fields will be considered for property generation and the
            /// PropertyChanging event will be implemented too.
            /// </summary>
            /// <remarks>
            /// The name of the property generated will be the Capitalized name of the field, minus any leading underscores.
            /// If the field is annotated with the 'PropertyName' attribute,
            /// the name of the property will be the value of the 'PropertyName' attribute.
            /// </remarks>
            /// <param name="generateEvent">
            ///     If true, the PropertyChanging event will be generated (as in: Added to the generated class).
            ///     If false, the PropertyChanging event will not be generated and must be supplied by the user.
            /// </param>
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            [CompilerGenerated]
            public class NotifyPropertyChangingAttribute(bool generateEvent = true) : Attribute {}
            
            
            /// <summary>
            /// Enum containing the possible validation strategies for the <see cref="ValidationStrategyAttribute"/>.
            /// </summary>
            [CompilerGenerated]
            public enum EValidationStrategy
            {
                /// <summary>
                /// Throw an exception when the validation fails.
                /// </summary>
                /// <remarks>
                /// This is the default behavior.
                /// </remarks>
                Exception,
        
                /// <summary>
                /// Rollback the changes when the validation fails.
                /// </summary>
                /// <remarks>
                /// Unless another property (eg. NotifyPropertyChanged) is also added,
                /// this mode behaves like the <see cref="Ignore"/> mode.
                /// If such a property is present, the corresponding side effects will be taken into account
                /// (eg. PropertyChanged event will be raised to notify the UI about the change in the value, albeit the
                /// value not having been changed in the underlying data store).
                /// </remarks>
                Rollback,
        
                /// <summary>
                /// Ignore the changes when the validation fails.
                /// </summary>
                /// <remarks>
                /// If changes are ignored, the code will exit immediately without any further action (without side effects).
                /// </remarks>
                Ignore,
            }
            
            /// <summary>
            /// Makes the field or class, annotated with the 'ValidationStrategy' attribute, create
            /// Properties which, for a given validation, will behave according to the specified strategy.
            /// </summary>
            /// <seealso cref="System.ComponentModel.DataAnnotations.MaxLengthAttribute"/>
            /// <seealso cref="System.ComponentModel.DataAnnotations.RangeAttribute"/>
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            [CompilerGenerated]
            public class ValidationStrategyAttribute(EValidationStrategy strategy = EValidationStrategy.Exception) : Attribute {}
            
            /// <summary>
            /// Makes the field annotated with the 'PropertyName' attribute, create a property with the specified name.
            /// </summary>
            [AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            [CompilerGenerated]
            public class PropertyNameAttribute(string name) : Attribute {}
        
            /// <summary>
            /// Enum containing the possible property encapsulation strategies for the <see cref="PropertyEncapsulationAttribute"/>.
            /// </summary>
            [CompilerGenerated]
            public enum EPropertyEncapsulation
            {
                /// <summary>
                /// The property will be public and accessible from anywhere.
                /// </summary>
                Public,
            
                /// <summary>
                /// The property will be protected and accessible from the containing class and its derived classes.
                /// </summary>
                Protected,
            
                /// <summary>
                /// The property will be private and accessible only from the containing class.
                /// </summary>
                Private,
            
                /// <summary>
                /// The property will be internal and accessible only from the containing assembly.
                /// </summary>
                Internal,
                
                /// <summary>
                /// The property will be protected internal and accessible from the containing class or the derived
                /// classes living in the same assembly.
                /// </summary>
                ProtectedInternal,
            }
            
            /// <summary>
            /// Allows to configure either the default property encapsulation (when applied to a class)
            /// or the property encapsulation for a specific field.
            /// </summary>
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            [CompilerGenerated]
            public class PropertyEncapsulationAttribute(EPropertyEncapsulation encapsulation = EPropertyEncapsulation.Public) : Attribute {}
            
            /// <summary>
            /// When applied to a field, it will make the property generated virtual, allowing to override it in derived classes.
            /// </summary>
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            [CompilerGenerated]
            public class VirtualPropertyAttribute : Attribute {}
            
            /// <summary>
            /// Allows changing the equality check for a property or disabling it entirely.
            /// </summary>
            [AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
            [CompilerGenerated]
            public class EqualityCheckAttribute(EEqualityCheckMode mode = EEqualityCheckMode.Default, float FloatEpsilon = Single.Epsilon, double DoubleEpsilon = Double.Epsilon, string? Custom = null) : Attribute{}
            
            
            /// <summary>
            /// Enum containing the possible equality check modes for the <see cref="EqualityCheckAttribute"/>.
            /// </summary>
            [CompilerGenerated]
            public enum EEqualityCheckMode
            {
                /// <summary>
                /// The default behavior, using `Equals` for reference types,
                /// `==` for value types and epsilon comparison for floating point types.
                /// </summary>
                /// <seealso cref="FloatEpsilon"/>
                /// <seealso cref="DoubleEpsilon"/>
                Default,
                
                /// <summary>
                /// The property will be checked for equality using the provided custom comparison.
                /// Here, `value` will be the new value and the field name will be the old value.
                /// All class members may be accessed from within the custom comparison.
                /// </summary>
                /// <seealso cref="GuardAttribute"/>
                Custom,
                
                /// <summary>
                /// The property will not be checked for equality.
                /// </summary>
                /// <remarks>
                /// Neither the <see cref="ValidateAttribute"/> nor the <see cref="GuardAttribute"/> depend on this setting.
                /// </remarks>
                None,
            }
            
            /// <summary>
            /// Allows to guard a property from being changed, failing the validation if the guard method does not return true.
            /// </summary>
            /// <remarks>
            /// The guard method will be looked up in the class containing the property unless the
            /// <see cref="className"/> parameter is set.
            /// The method must be accessible from the containing class, must return a <see cref="bool"/>
            /// and must accept two parameters.
            /// Sample method signature: `bool GuardMethodName(T oldValue, T newValue)`.
            /// </remarks>
            [AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
            [CompilerGenerated]
            public class GuardAttribute(string methodName, string? className = null) : Attribute{}
        }
        """;

    private const string NotifyPropertyChangedAttribute =
        "X39.SourceGenerators.Property.NotifyPropertyChangedAttribute";

    private const string NotifyPropertyChangingAttribute =
        "X39.SourceGenerators.Property.NotifyPropertyChangingAttribute";

    private const string ValidationStrategyAttribute =
        "X39.SourceGenerators.Property.ValidationStrategyAttribute";

    private const string PropertyNameAttribute = "X39.SourceGenerators.Property.PropertyNameAttribute";

    private const string PropertyEncapsulationAttribute =
        "X39.SourceGenerators.Property.PropertyEncapsulationAttribute";

    private const string VirtualPropertyAttribute =
        "X39.SourceGenerators.Property.VirtualPropertyAttribute";

    private const string EqualityCheckAttribute =
        "X39.SourceGenerators.Property.EqualityCheckAttribute";

    private const string GuardAttribute = "X39.SourceGenerators.Property.GuardAttribute";

    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(
            ctx => ctx.AddSource(
                "X39.SourceGenerators.Property.g.cs",
                SourceText.From(AttributeSourceCode, Encoding.UTF8)
            )
        );

        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var classSyntaxProvider = context.SyntaxProvider
                                         .CreateSyntaxProvider(
                                             (s,   _) => s is ClassDeclarationSyntax,
                                             (ctx, _) => GetClassDeclarationForSourceGen(ctx)
                                         )
                                         .Where(t => t.generateProperty)
                                         .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(classSyntaxProvider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right))
        );
    }

    /// <summary>
    /// Checks whether the Node is annotated with the [Report] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax, bool generateProperty) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax) context.Node;

        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            var symbolInfo = context.SemanticModel.GetSymbolInfo(attributeSyntax);
            if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the attribute.
            if (attributeName == NotifyPropertyChangedAttribute) return (classDeclarationSyntax, true);
            if (attributeName == NotifyPropertyChangingAttribute) return (classDeclarationSyntax, true);
            if (attributeName == ValidationStrategyAttribute) return (classDeclarationSyntax, true);
            // if (attributeName == PropertyNameAttribute) return (classDeclarationSyntax, true);
            if (attributeName == PropertyEncapsulationAttribute) return (classDeclarationSyntax, true);
            if (attributeName == VirtualPropertyAttribute) return (classDeclarationSyntax, true);
            if (attributeName == EqualityCheckAttribute) return (classDeclarationSyntax, true);
            // if (attributeName == GuardAttribute) return (classDeclarationSyntax, true);
        }

        // Go through all fields of the class.
        foreach (var field in classDeclarationSyntax.Members.OfType<FieldDeclarationSyntax>())
        foreach (AttributeListSyntax attributeListSyntax in field.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the attribute.
            if (attributeName == NotifyPropertyChangedAttribute) return (classDeclarationSyntax, true);
            if (attributeName == NotifyPropertyChangingAttribute) return (classDeclarationSyntax, true);
            if (attributeName == ValidationStrategyAttribute) return (classDeclarationSyntax, true);
            if (attributeName == PropertyNameAttribute) return (classDeclarationSyntax, true);
            if (attributeName == PropertyEncapsulationAttribute) return (classDeclarationSyntax, true);
            if (attributeName == VirtualPropertyAttribute) return (classDeclarationSyntax, true);
            if (attributeName == EqualityCheckAttribute) return (classDeclarationSyntax, true);
            if (attributeName == GuardAttribute) return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private static void GenerateCode(
        SourceProductionContext                context,
        Compilation                            compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        GenInfo GetGenerationInfo(IReadOnlyCollection<AttributeData> attributes)
        {
            bool?                                                            notifyPropertyChanged  = null;
            bool?                                                            notifyPropertyChanging = null;
            string?                                                          validationStrategy     = null;
            string?                                                          propertyName           = null;
            string?                                                          propertyEncapsulation  = null;
            bool?                                                            virtualProperty        = null;
            (string type, string from, string to)?                           range                  = null;
            int?                                                             maxLength              = null;
            (string mode, string epsilonF, string epsilonD, string? custom)? equalityCheck          = null;
            List<(string methodName, string? className)>                     guardMethods           = new();
            foreach (var attribute in attributes)
            {
                if (attribute.AttributeClass is null) continue;
                var attributeName = attribute.AttributeClass.ToDisplayString();
                switch (attributeName)
                {
                    case NotifyPropertyChangedAttribute:
                        notifyPropertyChanged = (bool?) attribute.ConstructorArguments[0].Value ?? true;
                        break;
                    case NotifyPropertyChangingAttribute:
                        notifyPropertyChanging = (bool?) attribute.ConstructorArguments[0].Value ?? true;
                        break;
                    case ValidationStrategyAttribute:
                        validationStrategy = attribute.ConstructorArguments[0].Value?.ToString() ?? "Exception";
                        break;
                    case PropertyNameAttribute:
                        propertyName = attribute.ConstructorArguments[0].Value?.ToString();
                        break;
                    case PropertyEncapsulationAttribute:
                        propertyEncapsulation = attribute.ConstructorArguments[0].Value?.ToString();
                        break;
                    case VirtualPropertyAttribute:
                        virtualProperty = true;
                        break;
                    case RangeAttribute when attribute.AttributeConstructor is not null
                                             && attribute.ConstructorArguments.Length is 2 or 3:
                    {
                        var first = attribute.AttributeConstructor.Parameters[0].Type.ToDisplayString();
                        switch (first)
                        {
                            case "double":
                            {
                                var from = attribute.ConstructorArguments[0].Value?.ToString().Replace(',', '.')
                                           ?? "0.0";
                                var to = attribute.ConstructorArguments[1].Value?.ToString().Replace(',', '.') ?? "0.0";
                                range = (first, from, to);
                                break;
                            }
                            case "int":
                            {
                                var from = attribute.ConstructorArguments[0].Value?.ToString() ?? "0";
                                var to   = attribute.ConstructorArguments[1].Value?.ToString() ?? "0";
                                range = (first, from, to);
                                break;
                            }
                            case "System.Type" when attribute.ConstructorArguments.Length is 3:
                            {
                                var from = attribute.ConstructorArguments[1].Value?.ToString() ?? "0";
                                var to   = attribute.ConstructorArguments[2].Value?.ToString() ?? "0";
                                range = (first, from, to);
                                break;
                            }
                            default: continue;
                        }

                        break;
                    }
                    case MaxLengthAttribute when attribute.ConstructorArguments.Length is 1:
                        maxLength = (int) (attribute.ConstructorArguments[0].Value ?? 0);
                        break;
                    case EqualityCheckAttribute:
                    {
                        var mode = attribute.ConstructorArguments[0].Value?.ToString()
                                   ?? attribute.NamedArguments.FirstOrDefault(a => a.Key == "mode")
                                               .Value.Value?.ToString()
                                   ?? "Default";
                        var epsilonF = attribute.ConstructorArguments[1].Value?.ToString()
                                       ?? attribute.NamedArguments.FirstOrDefault(a => a.Key == "FloatEpsilon")
                                                   .Value.Value?.ToString()
                                       ?? "Single.Epsilon";
                        var epsilonD = attribute.ConstructorArguments[2].Value?.ToString()
                                       ?? attribute.NamedArguments.FirstOrDefault(a => a.Key == "DoubleEpsilon")
                                                   .Value.Value?.ToString()
                                       ?? "Double.Epsilon";
                        var custom = attribute.ConstructorArguments[3].Value?.ToString()
                                     ?? attribute.NamedArguments.FirstOrDefault(a => a.Key == "Custom")
                                                 .Value.Value?.ToString();
                        equalityCheck = (mode, epsilonF, epsilonD, custom);
                        break;
                    }
                    case GuardAttribute:
                    {
                        var methodName = attribute.ConstructorArguments[0].Value?.ToString()
                                         ?? attribute.NamedArguments.FirstOrDefault(a => a.Key == "methodName")
                                                     .Value.Value?.ToString();
                        if (methodName is null) continue;
                        var className = attribute.ConstructorArguments[1].Value?.ToString()
                                        ?? attribute.NamedArguments.FirstOrDefault(a => a.Key == "className")
                                                    .Value.Value?.ToString();
                        guardMethods.Add((methodName, className));
                        break;
                    }
                }
            }

            return new GenInfo
            {
                NotifyPropertyChanged  = notifyPropertyChanged,
                NotifyPropertyChanging = notifyPropertyChanging,
                ValidationStrategy     = validationStrategy,
                PropertyName           = propertyName,
                PropertyEncapsulation  = propertyEncapsulation,
                VirtualProperty        = virtualProperty,
                Range                  = range,
                MaxLength              = maxLength,
                EqualityCheck          = equalityCheck,
                GuardMethods           = guardMethods
            };
        }

        string NormalizeFieldName(string origFieldName)
        {
            var fieldName = origFieldName.TrimStart('_');
            fieldName = fieldName.Substring(0, 1).ToUpper(CultureInfo.InvariantCulture) + fieldName.Substring(1);
            if (fieldName.EndsWith("Field", StringComparison.Ordinal) && fieldName != "Field")
                fieldName = fieldName.Substring(0, fieldName.Length - 5);
            if (origFieldName == fieldName) return string.Concat(fieldName, "Property");
            return fieldName;
        }

        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol) continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;

            var defaultGenInfo = GetGenerationInfo(classSymbol.GetAttributes());

            // Go through all fields of the class.
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine($"#nullable enable");
            builder.AppendLine($"using System;");
            builder.AppendLine($"using System.Collections.Generic;");
            builder.AppendLine();
            builder.AppendLine($"namespace {namespaceName};");
            builder.AppendLine($"partial class {className}");
            if (defaultGenInfo is {NotifyPropertyChanging: true, NotifyPropertyChanged: true})
                builder.AppendLine(
                    " : System.ComponentModel.INotifyPropertyChanged, System.ComponentModel.INotifyPropertyChanging"
                );
            else if (defaultGenInfo.NotifyPropertyChanged is true)
                builder.AppendLine(" : System.ComponentModel.INotifyPropertyChanged");
            else if (defaultGenInfo.NotifyPropertyChanging is true)
                builder.AppendLine(" : System.ComponentModel.INotifyPropertyChanging");
            builder.AppendLine("{");
            if (defaultGenInfo.NotifyPropertyChanging is true)
                builder.AppendLine(
                    "    public event System.ComponentModel.PropertyChangingEventHandler? PropertyChanging;"
                );
            if (defaultGenInfo.NotifyPropertyChanged is true)
                builder.AppendLine(
                    "    public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;"
                );

            foreach (var fieldSymbol in classSymbol.GetMembers().OfType<IFieldSymbol>())
            {
                var currentGenInfo = GetGenerationInfo(fieldSymbol.GetAttributes()).WithDefaults(defaultGenInfo);
                if (!currentGenInfo.GenerateProperty()) continue;
                var propertyName = currentGenInfo.PropertyName ?? NormalizeFieldName(fieldSymbol.Name);
                var propertyType = fieldSymbol.Type.ToDisplayString();
                builder.Append("    "); // Indentation.
                builder.Append(
                    currentGenInfo.PropertyEncapsulation switch
                    {
                        "0" => "public",
                        "1" => "protected",
                        "2" => "private",
                        "3" => "internal",
                        "4" => "protected internal",
                        _   => "public",
                    }
                );
                builder.Append(' ');
                if (currentGenInfo.VirtualProperty is true) builder.Append("virtual ");
                builder.Append(propertyType);
                builder.Append(' ');
                builder.Append(propertyName);
                builder.AppendLine();
                builder.AppendLine("    {");
                builder.AppendLine($"        get => {fieldSymbol.Name};");
                builder.AppendLine("        set");
                builder.AppendLine("        {");

                WriteOutEqualityCheck(currentGenInfo, propertyType, builder, fieldSymbol);
                WriteOutNotifyPropertyChanging(currentGenInfo, builder, propertyName);
                WriteOutRangeValidation(currentGenInfo, builder, propertyName);
                WriteOutMaxLengthValidation(currentGenInfo, builder, propertyName);
                WriteOutGuards(currentGenInfo, builder, fieldSymbol, propertyName);
                builder.AppendLine($"            {fieldSymbol.Name} = value;");
                WriteOutPropertyChanged(currentGenInfo, builder, propertyName);

                builder.AppendLine("        }");
                builder.AppendLine("    }");
            }

            builder.AppendLine("}");

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }

    private static void WriteOutGuards(
        GenInfo currentGenInfo, StringBuilder builder, IFieldSymbol fieldSymbol, string propertyName)
    {
        foreach (var guardMethod in currentGenInfo.GuardMethods)
        {
            var method = guardMethod.className is null
                ? guardMethod.methodName
                : string.Concat(guardMethod.className, ".", guardMethod.methodName);
            builder.AppendLine($"            if (!{method}({fieldSymbol.Name}, value))");
            WriteOutValidationStrategyOutcome(currentGenInfo, builder, propertyName, $"Guard method {method} failed");
        }
    }

    private static void WriteOutMaxLengthValidation(GenInfo currentGenInfo, StringBuilder builder, string propertyName)
    {
        if (currentGenInfo.MaxLength is null) return;
        builder.AppendLine($"            if (value.Length > {currentGenInfo.MaxLength})");
        WriteOutValidationStrategyOutcome(
            currentGenInfo,
            builder,
            propertyName,
            $"Value must be at most {currentGenInfo.MaxLength} characters long"
        );
    }

    private static void WriteOutRangeValidation(GenInfo currentGenInfo, StringBuilder builder, string propertyName)
    {
        if (currentGenInfo.Range is null) return;

        var (type, from, to) = currentGenInfo.Range.Value;
        switch (type)
        {
            case "float":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "double":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "sbyte":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "byte":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "short":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "ushort":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "int":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "uint":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "long":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "ulong":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "decimal":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "bool":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "nint":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "unint":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            case "char":
                builder.AppendLine($"            if (value < {from} || value > {to})");
                break;
            default:
                builder.AppendLine($"            if (value.CompareTo({from}) < 0 || value.CompareTo({to}) > 0)");
                break;
        }

        WriteOutValidationStrategyOutcome(
            currentGenInfo,
            builder,
            propertyName,
            $"Value must be between {from} and {to}"
        );
    }

    private static void WriteOutValidationStrategyOutcome(
        GenInfo currentGenInfo, StringBuilder builder, string propertyName, string reason)
    {
        switch (currentGenInfo.ValidationStrategy)
        {
            default:
            // ReSharper disable once RedundantCaseLabel
            case "0":
            // ReSharper disable once RedundantCaseLabel
            case null:
                builder.AppendLine(
                    $"                throw new System.ArgumentException(\"Validation of {propertyName} failed: {reason}\", nameof(value));"
                );
                break;
            case "1" when currentGenInfo.NotifyPropertyChanged is true:
                builder.AppendLine("            {");
                builder.AppendLine(
                    $"                this.PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(\"{propertyName}\"));"
                );
                builder.AppendLine("                return;");
                builder.AppendLine("            }");
                break;
            case "1":
            case "2":
                builder.AppendLine("                return;");
                break;
        }
    }

    private static void WriteOutPropertyChanged(GenInfo currentGenInfo, StringBuilder builder, string propertyName)
    {
        if (currentGenInfo.NotifyPropertyChanged is not null)
        {
            builder.AppendLine(
                $"            this.PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(\"{propertyName}\"));"
            );
        }
    }

    private static void WriteOutNotifyPropertyChanging(
        GenInfo currentGenInfo, StringBuilder builder, string propertyName)
    {
        if (currentGenInfo.NotifyPropertyChanging is not null)
        {
            builder.AppendLine(
                $"            this.PropertyChanging?.Invoke(this, new System.ComponentModel.PropertyChangingEventArgs(\"{propertyName}\"));"
            );
        }
    }

    private static void WriteOutEqualityCheck(
        GenInfo currentGenInfo, string propertyType, StringBuilder builder, IFieldSymbol fieldSymbol)
    {
        switch (currentGenInfo.EqualityCheck)
        {
            default:
            // ReSharper disable once RedundantCaseLabel
            case null:
            // ReSharper disable once RedundantCaseLabel
            case ("0", _, _, _):
                switch (propertyType)
                {
                    case "System.Single":
                        builder.AppendLine(
                            $"            if (Math.Abs(value - {fieldSymbol.Name}) < {currentGenInfo.EqualityCheck?.epsilonF ?? "Single.Epsilon"}) return;"
                        );
                        break;
                    case "System.Double":
                        builder.AppendLine(
                            $"            if (Math.Abs(value - {fieldSymbol.Name}) < {currentGenInfo.EqualityCheck?.epsilonF ?? "Double.Epsilon"}) return;"
                        );
                        break;
                    case "System.SByte":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.Byte":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.Int16":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.UInt16":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.Int32":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.UInt32":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.Int64":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.UInt64":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.Decimal":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.Boolean":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.IntPtr":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.UIntPtr":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    case "System.Char":
                        builder.AppendLine($"            if (value == {fieldSymbol.Name}) return;");
                        break;
                    default:
                        builder.AppendLine($"            if (value.Equals({fieldSymbol.Name})) return;");
                        break;
                }

                break;
            case ("1", _, _, { } customMethod):
                builder.AppendLine($"            if ({customMethod}({fieldSymbol.Name}, value)) return;");
                break;
            case ("2", _, _, _): break;
        }
    }
}
